<html>
<body>

<script src="js/third_party/three.js/three.min.js"></script>
<script src="../build/artoolkit.debug.js"></script>
<script src="../js/artoolkit.api.js"></script>

<video id="v" src="Data/output_4.ogg" width="320" height="240" loop="infinite" controls="" autoplay webkit-playsinline></video>
<video id="v2" src="Data/output_4.ogg" width="320" height="240" loop="infinite" controls="" autoplay webkit-playsinline></video>
<script id="vert" type="glsl-vertex">
precision highp float;
precision lowp int;

uniform mat4 cameraMatrix;
uniform mat4 transformationMatrix;

varying vec2 vUv;

void main(void)
{
	vUv = uv;
	gl_Position = cameraMatrix * transformationMatrix * vec4(position, 1.0);
}
</script>

<script id="frag" type="glsl-fragment">
precision highp float;
precision lowp int;

varying vec2 vUv;

void main(void)
{
	gl_FragColor = vec4(vUv, 1.0, 1.0);
}
</script>

<script>

// create a div that we can overlay with rendered stuff (note the left and top attributes, adjust to align with the video)
canvasContainer = document.createElement('div');
document.body.appendChild(canvasContainer);
canvasContainer.style.position="absolute";
canvasContainer.style.left="8px";
canvasContainer.style.top="8px";


var cMat = new THREE.Matrix4();
var tMat = new THREE.Matrix4();

var USE_SHADER = true;
//var parameters = { wireframe: true  };
var shaderMaterial = new THREE.ShaderMaterial(
{
	uniforms: {
		cameraMatrix: {type: 'm4', value: cMat },
		transformationMatrix: {type: 'm4', value: tMat }
	},
	vertexShader: vert.text,
	fragmentShader: frag.text
});
shaderMaterial.wireframe=false;

//var renderer = new THREE.WebGLRenderer();
var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

var scene = new THREE.Scene();

renderer.setSize(v.width, v.height);

//document.body.appendChild(renderer.domElement);
// Overlay the rendered graphics on top of the video
canvasContainer.appendChild(renderer.domElement);

// Create a camera and a marker root object for your Three.js scene.
var camera = new THREE.Camera();
scene.add(camera);

var light = new THREE.PointLight(0xffffff);
light.position.set(400, 500, 100);
scene.add(light);
var light = new THREE.PointLight(0xffffff);
light.position.set(-400, -500, -100);
scene.add(light);

var markerRoot = new THREE.Object3D();
		// var markerRoot = arController.createThreeBarcodeMarker(20);

markerRoot.wasVisible = false;
markerRoot.markerMatrix = new Float64Array(12);
markerRoot.matrixAutoUpdate = false;
camera.matrixAutoUpdate = false;

// Add the marker models and suchlike into your marker root object.

var cube = new THREE.Mesh(
	new THREE.BoxGeometry(1,1,1),
	USE_SHADER ?
		shaderMaterial :
		new THREE.MeshLambertMaterial({ color: 0xffffff, wireframe: false })
);

var sphere = new THREE.Mesh(
		new THREE.SphereGeometry(0.7, 8, 8),
		USE_SHADER ?
		shaderMaterial :
		new THREE.MeshLambertMaterial({ color: 0xffffff, wireframe: false })
		);
//sphere.material.shading = USE_SHADER ? shaderMaterial : THREE.FlatShading;

// markerRoot.add(sphere);
markerRoot.add(cube);

// Add the marker root to your scene.
scene.add(markerRoot);
var arController = null;

var video = document.getElementById('v');

// On every frame do the following:
function tick() {
	requestAnimationFrame(tick);

	if (!arController) {
		return;
	}

	// arController.detectMarker(video);
	arController.process(video);
	var markerNum = arController.getMarkerNum();
			console.log("markers found ", markerNum);

	if (markerNum > 0) {
		// if (markerRoot.visible) {
		if (false) {
			arController.getTransMatSquareCont(0, 1, markerRoot.markerMatrix, markerRoot.markerMatrix);
		} else {
			arController.getTransMatSquare(0 /* Marker index */, 1 /* Marker width */, markerRoot.markerMatrix);
		}
		markerRoot.visible = true;
		if (USE_SHADER) {
			arController.transMatToGLMat(markerRoot.markerMatrix, shaderMaterial.uniforms.transformationMatrix.value.elements);
		} else {
			arController.transMatToGLMat(markerRoot.markerMatrix, markerRoot.matrix.elements);
		}
	} else {
		markerRoot.visible = false;
	}

	arController.debugDraw();
	cube.rotation.z += 0.2;
	// Render the scene.
	renderer.autoClear = false;
	renderer.clear();
	renderer.render(scene, camera);
}

tick();

var cameraParam = new ARCameraParam();
cameraParam.onload = function() {

	arController = new ARController(320, 240, cameraParam);
	arController.debugSetup();

	var camera_mat = arController.getCameraMatrix();

	if (USE_SHADER) {
		shaderMaterial.uniforms.cameraMatrix.value.elements.set(camera_mat);
	} else {
		camera.projectionMatrix.elements.set(camera_mat);
	}

};
cameraParam.load('Data/camera_para.dat');

</script>

</body>
</html>